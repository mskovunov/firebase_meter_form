#define TINY_GSM_MODEM_SIM800
#define TINY_GSM_RX_BUFFER 1024

#include <WiFi.h>
#include <HTTPClient.h> // Библиотека для прямого HTTPS (Wi-Fi)
#include <TinyGsmClient.h>
#include <ArduinoHttpClient.h> // Библиотека для PushingBox (GSM)
#include <PZEM004Tv30.h>        // Для PZEM
#include <Firebase_ESP_Client.h>
#include <addons/TokenHelper.h>
#include <esp_task_wdt.h>       // Сторожевой таймер
#include <time.h>               // Время для логов

// ================= НАСТРОЙКИ =================
const bool ENABLE_WIFI = true;
const bool ENABLE_GSM = true;

const char *wifi_ssid = "Xiaomi_9D58";
const char *wifi_pass = "Am5084ak";

// --- НАСТРОЙКИ ДЛЯ БЕЗЛИМИТНОГО WI-FI (Google) ---
// Вставьте сюда ID вашего скрипта (Длинная строка из URL между /s/ и /exec)
String GAS_SCRIPT_ID = "AKfycbyvn_NXzYXWankzZan3efMbUaQZNpjjNCBcmJNrGPHHkUoAfASHqMpmiy_Sm_Yuzt4d";

// --- НАСТРОЙКИ ДЛЯ РЕЗЕРВНОГО GSM (PushingBox) ---
const char apn[] = "internet";
const char user[] = "";
const char pass[] = "";
const char *DEVID = "vA48E437DF1936FA"; // Ваш ID из PushingBox

// --- Firebase (Firestore) ---
#define API_KEY "AIzaSyAsr-JbArcAu-7_csBxM6VDsC7hyPz7qB0"
#define FIREBASE_PROJECT_ID "meter-form"
#define USER_EMAIL "esp32@test.com"
#define USER_PASSWORD "123456"

// ================= ПИНЫ =================
#define MODEM_RST 23
#define MODEM_TX 17
#define MODEM_RX 16

// PZEM (Serial1 - ВАЖНО: Используем Serial1 на кастомных пинах)
#define PZEM_RX_PIN 26
#define PZEM_TX_PIN 27

#define MAINS_PIN 4
#define BAT_PIN 34

// Тайм-аут зависания (120 секунд)
#define WDT_TIMEOUT 120

// Настройки времени
const char *ntpServer = "pool.ntp.org";
const long gmtOffset_sec = 7200;     // UTC+2
const int daylightOffset_sec = 3600; 

#define SerialMon Serial
#define SerialAT Serial2

// ================= КЛИЕНТЫ =================
// PZEM на Serial1 (HardwareSerial 1)
HardwareSerial SerialPZEM(1); 
PZEM004Tv30 pzem(SerialPZEM, PZEM_RX_PIN, PZEM_TX_PIN);

WiFiClient clientWifi;
TinyGsm modem(SerialAT);
TinyGsmClient clientGsm(modem);
HttpClient httpGsm(clientGsm, "api.pushingbox.com", 80);

// Firebase Объекты
FirebaseData fbdo;
FirebaseAuth auth;
FirebaseConfig config;

bool isPowerOn = true;
unsigned long lastKeepAlive = 0;

// ИЗМЕНЕНИЕ: Переменная для динамического интервала БАТАРЕИ (по умолчанию 5 минут)
unsigned long sendInterval = 300000; 

// НОВОЕ: Переменная для динамического интервала PZEM (по умолчанию 60 сек)
unsigned long sendIntervalPzem = 60000;
unsigned long sendPzemPrevMillis = 0;

// Предварительное объявление функций, чтобы не было ошибок компиляции
int getBatteryPercentage(bool charging, float &outVoltage);
void sendSmart(int val, String deviceStatus, int batLevel, float voltage);
String getCurrentTime();
// updatePzemInterval удалена, так как чтение теперь в sendSmart

void setup()
{
    SerialMon.begin(115200);
    // ПРАВКА 1: Даем питанию стабилизироваться при включении
    delay(2000);

    // 1. Настройка WDT (Сторожевой пес) - С ИСПРАВЛЕНИЕМ ОШИБКИ Init
    SerialMon.println("Configuring WDT...");
    esp_task_wdt_deinit(); // Убиваем старый таймер
    esp_task_wdt_config_t wdt_config = {
        .timeout_ms = WDT_TIMEOUT * 1000,
        .idle_core_mask = (1 << portNUM_PROCESSORS) - 1,
        .trigger_panic = true
    };
    esp_task_wdt_init(&wdt_config);
    esp_task_wdt_add(NULL);

    pinMode(MAINS_PIN, INPUT);
    pinMode(BAT_PIN, INPUT);

    // 1. Инициализация GSM (Только если разрешено)
    if (ENABLE_GSM)
    {
        SerialAT.begin(57600, SERIAL_8N1, MODEM_RX, MODEM_TX);
        delay(3000);
        SerialMon.println("System Start. Init Modem...");
        modem.restart();
        httpGsm.setHttpResponseTimeout(90000);
    }
    esp_task_wdt_reset();

    // ПРАВКА 2: Пауза между GSM и Wi-Fi, чтобы не было скачка тока
    delay(2000);
    // 2. Инициализация Wi-Fi (Только если разрешено)
    if (ENABLE_WIFI)
    {
        SerialMon.println("Init Wi-Fi...");
        WiFi.mode(WIFI_STA);
        WiFi.begin(wifi_ssid, wifi_pass);
        
        unsigned long startWifi = millis();
        // Добавил выход по таймауту, чтобы не висело вечно
        while (WiFi.status() != WL_CONNECTED && millis() - startWifi < 20000) {
            SerialMon.print(".");
            delay(300);
            esp_task_wdt_reset();
        }
        if (WiFi.status() == WL_CONNECTED) SerialMon.println("\nWiFi Connected!");
        else SerialMon.println("\nWiFi Failed");
    }

    // 3. Инициализация Времени (NTP) - ВАЖНО ДЛЯ FIREBASE
    if (WiFi.status() == WL_CONNECTED) {
        configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);
        struct tm timeinfo;
        unsigned long startNtp = millis();
        while (!getLocalTime(&timeinfo) && millis() - startNtp < 20000) {
            SerialMon.print("."); delay(500); esp_task_wdt_reset();
        }
        if (getLocalTime(&timeinfo)) SerialMon.println("\nTime Synced: " + getCurrentTime());
        else {
             SerialMon.println("\nTime Sync FAILED! Trying backup...");
             configTime(gmtOffset_sec, daylightOffset_sec, "time.google.com");
        }
    }

    // 4. Инициализация Firebase
    config.api_key = API_KEY;
    auth.user.email = USER_EMAIL;
    auth.user.password = USER_PASSWORD;
    config.token_status_callback = tokenStatusCallback;
    Firebase.begin(&config, &auth);
    Firebase.reconnectWiFi(true);

    // Проверка статуса при старте
    if (digitalRead(MAINS_PIN) == HIGH)
    {
        isPowerOn = true;
        SerialMon.println("STARTUP: Power ON");
    }
    else
    {
        isPowerOn = false;
        SerialMon.println("STARTUP: Power OFF");
    }

    // ПРАВКА 3: Отправляем приветственное сообщение, чтобы убедиться, что система не зависла
    SerialMon.println("Setup Done. Sending Boot Info...");

    // ИЗМЕНЕНИЕ: Добавили переменную для вольтажа
    float currentVolt = 0.0;
    int bat = getBatteryPercentage(isPowerOn, currentVolt);

    // ИЗМЕНЕНИЕ: Передаем вольтаж в sendSmart
    sendSmart(1, "SystemStart", bat, currentVolt);
    
    sendPzemPrevMillis = millis(); // Старт таймера PZEM
}

void loop()
{
    esp_task_wdt_reset(); // Кормим собаку

    int sensorVal = digitalRead(MAINS_PIN);
    bool currentReading = (sensorVal == HIGH);

    if (currentReading != isPowerOn)
    {
        delay(500);
        if (digitalRead(MAINS_PIN) == sensorVal)
        {
            isPowerOn = currentReading;

            // ИЗМЕНЕНИЕ: Получаем вольтаж
            float currentVolt = 0.0;
            int bat = getBatteryPercentage(isPowerOn, currentVolt);

            if (isPowerOn)
            {
                SerialMon.println("EVENT: Power Restored");
                sendSmart(1, "PowerRestored", bat, currentVolt);
            }
            else
            {
                SerialMon.println("EVENT: Power Lost");
                sendSmart(0, "PowerLost", bat, currentVolt);
            }
            // Пауза для очистки буфера SSL после отправки
            delay(2000); 
        }
    }

    // --- ЗАДАЧА 2: ОТЧЕТ PZEM (FIREBASE) ---
    // НОВОЕ: Используем переменную sendIntervalPzem вместо числа 60000
    if (WiFi.status() == WL_CONNECTED && Firebase.ready() && (millis() - sendPzemPrevMillis > sendIntervalPzem)) {
        
        sendPzemPrevMillis = millis();
        esp_task_wdt_reset();

        float voltage = pzem.voltage();
        float current = pzem.current();
        float power = pzem.power();
        float energy = pzem.energy();

        // Фильтр ошибок
        if (isnan(voltage) || voltage < 0) voltage = 0.0;
        if (isnan(current) || current < 0) current = 0.0;
        if (isnan(power) || power < 0) power = 0.0;
        if (isnan(energy) || energy < 0) energy = 0.0;

        // Округляем
        double cleanVoltage = round(voltage * 10) / 10.0;
        double cleanCurrent = round(current * 1000) / 1000.0;
        double cleanPower = round(power * 10) / 10.0;
        double cleanEnergy = round(energy * 1000) / 1000.0;

        String timeStr = getCurrentTime();
        SerialMon.println("--------------------------------------");
        SerialMon.printf("[%s] PZEM READINGS (Int: %ds):\n", timeStr.c_str(), sendIntervalPzem/1000);
        SerialMon.printf("Voltage: %.1f V\n", cleanVoltage);
        SerialMon.printf("Current: %.3f A\n", cleanCurrent);
        SerialMon.printf("Power:   %.1f W\n", cleanPower);
        SerialMon.printf("Energy:  %.3f kWh\n", cleanEnergy);
        SerialMon.println("Sending to Firebase...");
        SerialMon.println("--------------------------------------");

        FirebaseJson content;
        content.set("fields/voltage/doubleValue", cleanVoltage);
        content.set("fields/current/doubleValue", cleanCurrent);
        content.set("fields/power/doubleValue", cleanPower);
        content.set("fields/energy/doubleValue", cleanEnergy);
        content.set("fields/created_at/stringValue", timeStr);
        content.set("fields/timestamp_unix/integerValue", (int)time(nullptr));

        if (Firebase.Firestore.createDocument(&fbdo, FIREBASE_PROJECT_ID, "", "meter_readings", content.raw())) {
            SerialMon.println(">>> FIREBASE SUCCESS.");
            // ЗДЕСЬ УБРАН ВЫЗОВ updatePzemInterval(), ТАК КАК ЧИТАЕМ ЧЕРЕЗ GAS
        } else {
            SerialMon.printf(">>> FIREBASE ERROR: %s\n", fbdo.errorReason().c_str());
        }
        
        lastKeepAlive = millis() + 5000; // Сдвигаем таймер GAS
        esp_task_wdt_reset();
    }

    // ТЕПЕРЬ МОЖНО ЧАЩЕ! ИЗМЕНЕНИЕ: Используем переменную sendInterval вместо числа 60000
    // Wi-Fi "бесплатный", а GSM будет тратить лимит PushingBox только при аварии
    if (millis() - lastKeepAlive > sendInterval)
    {
        // Проверка на конфликт с PZEM
        if (millis() - sendPzemPrevMillis < 5000) {
            // Ждем
        } else {
            // ИЗМЕНЕНИЕ: Получаем вольтаж
            float currentVolt = 0.0;
            int bat = getBatteryPercentage(isPowerOn, currentVolt);

            SerialMon.print("Routine Check (Interval: ");
            SerialMon.print(sendInterval / 1000);
            SerialMon.println("s)...");
            
            sendSmart(isPowerOn ? 1 : 0, "RoutineCheck", bat, currentVolt);
            lastKeepAlive = millis();
        }
    }
    delay(100);
}

// ================= ФУНКЦИИ =================

// ИЗМЕНЕНИЕ: Добавлен аргумент float voltage
void sendSmart(int val, String deviceStatus, int batLevel, float voltage)
{
    bool sent = false;

    // --- 1. КАНАЛ WI-FI (ПРЯМОЙ В GOOGLE - БЕЗЛИМИТ) ---
    if (ENABLE_WIFI)
    {
        // Реконнект если нужно
        if (WiFi.status() != WL_CONNECTED)
        {
            SerialMon.print("Wi-Fi reconnecting...");
            WiFi.reconnect();
            for (int i = 0; i < 30; i++)
            {
                if (WiFi.status() == WL_CONNECTED)
                    break;
                SerialMon.print(".");
                delay(100);
                esp_task_wdt_reset();
            }
            SerialMon.println();
        }

        if (WiFi.status() == WL_CONNECTED)
        {
            HTTPClient http;

            // Формируем прямой URL для Google Script
            String url = "https://script.google.com/macros/s/" + GAS_SCRIPT_ID + "/exec";
            url += "?val=" + String(val);
            url += "&device=" + deviceStatus;
            url += "&bat=" + String(batLevel);
            url += "&volt=" + String(voltage, 2); // ИЗМЕНЕНИЕ: Добавлен вольтаж в URL

            // ВАЖНО: Разрешаем переадресацию (Google всегда делает Redirect 302)
            http.setFollowRedirects(HTTPC_STRICT_FOLLOW_REDIRECTS);

            // Отключаем проверку сертификата (чтобы не менять его каждые 3 месяца)
            http.begin(url);

            SerialMon.print("[Wi-Fi Direct] Sending... ");
            int httpCode = http.GET();

            if (httpCode == 200)
            {
                // ИЗМЕНЕНИЕ: Читаем ответ от Google Script
                // ТЕПЕРЬ ОЖИДАЕМ ДВА ЧИСЛА ЧЕРЕЗ ЗАПЯТУЮ: "300,60"
                String payload = http.getString();
                SerialMon.print("GAS Response: ");
                SerialMon.println(payload);
                
                int commaIndex = payload.indexOf(',');
                
                if (commaIndex > 0) {
                     // 1. Интервал батареи
                     String batStr = payload.substring(0, commaIndex);
                     int newBatSec = batStr.toInt();
                     if (newBatSec >= 10 && newBatSec <= 3600) {
                         sendInterval = newBatSec * 1000;
                     }
                     
                     // 2. Интервал PZEM
                     String pzemStr = payload.substring(commaIndex + 1);
                     int newPzemSec = pzemStr.toInt();
                     if (newPzemSec >= 10 && newPzemSec <= 3600) {
                         if (sendIntervalPzem != newPzemSec * 1000) {
                             sendIntervalPzem = newPzemSec * 1000;
                             SerialMon.printf(">>> CONFIG UPDATED: PZEM Interval %d sec\n", newPzemSec);
                         }
                     }
                } else {
                     // Если пришло только одно число (на всякий случай)
                     int newBatSec = payload.toInt();
                     if (newBatSec >= 10 && newBatSec <= 3600) sendInterval = newBatSec * 1000;
                }
                
                sent = true;
            }
            else
            {
                SerialMon.print("Error: ");
                SerialMon.println(httpCode);
            }
            http.end();
        }
    }

    // --- 2. КАНАЛ GSM (РЕЗЕРВ ЧЕРЕЗ PUSHINGBOX) ---
    // Используется только если Wi-Fi не смог отправить
    if (!sent && ENABLE_GSM)
    {
        SerialMon.println("[GSM] Switching to Backup (PushingBox)...");

        if (!modem.isGprsConnected())
        {
            SerialMon.print("[GSM] Connecting GPRS... ");
            if (!modem.gprsConnect(apn, user, pass))
            {
                SerialMon.println("FAIL. Resetting modem...");
                modem.restart();
                return;
            }
            SerialMon.println("OK");
        }

        // Старый добрый URL для PushingBox
        String path = "/pushingbox?devid=" + String(DEVID) +
                      "&val=" + String(val) +
                      "&device=" + deviceStatus +
                      "&bat=" + String(batLevel) +
                      "&volt=" + String(voltage, 2); // ИЗМЕНЕНИЕ: Добавлен вольтаж в URL

        SerialMon.print("[GSM] Sending... ");
        httpGsm.stop();
        int err = httpGsm.get(path);

        if (err == 0)
        {
            SerialMon.println("Success! (Backup used)");
            httpGsm.responseBody();
        }
        else
        {
            SerialMon.println("Error via GSM: " + String(err));
        }
    }
}

// === БАТАРЕЯ (ФИНАЛЬНАЯ КАЛИБРОВКА: 2.12 и 2.34 - КАК ВЫ ПРОСИЛИ) ===
// === БАТАРЕЯ (УБИРАЕМ ЗАВЫШЕНИЕ ПРИ РАЗРЯДЕ) ===
int getBatteryPercentage(bool charging, float &outVoltage)
{
    long sum = 0;
    // Делаем 50 замеров чтобы сгладить пульсации GSM
    for (int i = 0; i < 50; i++) 
    {
        sum += analogRead(BAT_PIN);
        delay(2);
    }
    float average = sum / 50.0;
    
    if (charging)
    {
        // Свет есть: коэффициент 2.12 (Тут у тебя все четко, совпадает с мультиметром)
        outVoltage = (average / 4095.0) * 3.3 * 2.12;
    }
    else
    {
        // Света нет: СНИЖАЕМ с 2.42 до 2.34
        outVoltage = (average / 4095.0) * 3.3 * 2.34;
    }

    int percentage = 0;
    float v = outVoltage;

    // Таблица под реальные 4.15В
    if (v >= 4.15) percentage = 100;
    else if (v >= 4.05) percentage = 95;
    else if (v >= 3.95) percentage = 85;
    else if (v >= 3.85) percentage = 75;
    else if (v >= 3.75) percentage = 60;
    else if (v >= 3.65) percentage = 40;
    else if (v >= 3.50) percentage = 15;
    else percentage = 0;

    // Визуальная коррекция при зарядке
    if (charging && percentage < 100 && v > 3.9) {
        percentage += 2; 
        if (percentage > 100) percentage = 100;
    }

    SerialMon.print("Bat: ");
    SerialMon.print(outVoltage);
    SerialMon.print("V | ");
    SerialMon.print(percentage);
    SerialMon.println("%");
    return percentage;
}

String getCurrentTime() {
    struct tm timeinfo;
    if (!getLocalTime(&timeinfo)) return "TimeError";
    char timeStringBuff[50];
    strftime(timeStringBuff, sizeof(timeStringBuff), "%Y-%m-%d %H:%M:%S", &timeinfo);
    return String(timeStringBuff);
}